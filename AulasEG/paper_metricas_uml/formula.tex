Após lermos bastante documentação sobre as expressões matemáticas que definem este tipo de avaliação encontramos as medidas definidas por \cite{Peter}
que definimos aqui e explicamos com algum detalhe.\\

Temos então quatro grandes grupos de medidas que pudemos usar para definir as fórmulas que vão ser usadas para análise dos diagramas e
consequentemente extracção de uma métrica de qualidade para os diagramas UML.
\paragraph{Métricas primitivas} que consistem na extracção bruta de informaçao no que diz respeito á quantidade de métodos, classes, parametros, etc.
Temos que o número total de classes (\textit{Total Number of Classes}) é $$TNC = \sum_{i=1}^{n} tnc_i $$
o número total de relações herdadas (\textit{Total Number of Inheritance Relationships})  $$TNIR = \sum_{i=1}^{n} tnir_i $$
o número total de relações que ão sejam herdadas (\textit{ Total Number of Realization Relationships})  $$TNRR = \sum_{i=1}^{n} tnrr_i $$ por isto entende-se
uma relação entre dois elementos do modelo UML, entre dois diagramas de classes, cujo elemento cliente conhece o comportamento do outro elemento a que ele está ligado.
Temos ainda a contagem do número total de relações que existem (\textit{Total Number of Use Relationships})  $$TNUR = \sum_{i=1}^{n} tnur_i $$
o número total de associações (\textit{Total Number of Associations})    $$TNA = \sum_{i=1}^{n} tna_i $$
Uma associação representa uma relação entre duas classes. Por exemplo, numa relação entre duas classes, podemos usar associações para mostrar as decisões de design
que fizemos sobre a classe e para mostrar ainda que classe precisa dos atributos da outra.
Número total de operações (\textit{Total Number of Operation})   $$TNO = \sum_{i=1}^{n} tno_i $$
Número total de parametros (\textit{Total Number of Parameters})  $$TNP = \sum_{i=1}^{n} tnp_i $$
Número total de atributos de uma classe (\textit{Total Number of Class Attributes})  $$TNCA = \sum_{i=1}^{n} tnca_i $$

\paragraph{Métricas de propensão a falhas} (\textit{Fault-Proneness Metrics}) este grupo de métricas tem este nome porque são muito orientadas a hierarquia dos diagramas
de classes, assim sendo se houver um erro numa classe root esse erro será propagado para as classes filho que herdam.
Temos três formulas que nos ajudam a ganhar conhecimento sobre a propensão a falhas que o nosso diagrama de classes tem:
Peso de cada método por classe (\textit{Weighted Method per Class}) 
\begin{displaymath}
WMC = \sum_{i=1}^{n} c_i  \textrm{, onde $c_i$ é a complexidade dos métodos.}
\end{displaymath}

Número de sub classes que cada classe tem (\textit{Number of Children per Class})
\begin{displaymath}
NOC = \sum_{i=1}^{n} sc_i  \textrm{, onde $sc_i$ é o número de subclasses imediatas.}
\end{displaymath}
Profundidade da árvore de herança (\textit{Depth of Inheritance Tree})
\begin{displaymath}
DIT = max\_leng  \textrm{, onde $ max\_leng $ é o comprimento máximo desde a raiz até à folha.}
\end{displaymath}

\paragraph{Métricas de qualidade} (\textit{Quality Measure Metrics}) Este grupo de métricas são as mais interessantes do ponto de vista da qualidade, visto que
usam as anteriormente definidas como ferramenta para se chegar a uma conclusão sobre a qualidade do diagrama UML em questão.
Os diagramas de UML, tal como as linguagens de programação que recorrem ao modelo orientado a objectos teem a noção de protecção de elementos que definem uma class,
quer seja um método, uma variável de instância ou uma propriedade. Por isso é importante medir também este factor, assime existe o MHF (\textit{Method Hiding Factor}),
podemos dizer que esta métrica é a medida do uso de informação através de métodos e define-se por:
\begin{displaymath}
\frac{\sum_{i=1}^{rc} \sum_{m=1}^{Md(c_i)} (1-V(M_{mi}))} {\sum_{i=1}^{rc} Md(c_i)}
\end{displaymath}
onde:
$$V(M_{mi}) = \frac{\sum_{j=i}^{rc} is\_visible(M_{mi},C_j)}{TC-1} $$

\[ is\_visible(M_{mi},C_j) = \left\{ \begin{array}{l l}
	1 & \quad iff \left \{
		\begin{array}{l l}
			j \neq i \\
			C_j \texttt{may call} M_{mi}\\
		\end{array}
	\right.\\
0 & \quad otherwise\\
\end{array} \right. \]
$$TC = \textrm{Número total de classes}$$
$$Md = \textrm{Número total de métodos definidos}$$
$$V(M_{mi}) = \textrm{A visibilidade de todas as classes onde o método $M_{mi}$ é visível}$$
\\
De seguinda temos a métrica que mede a herdagem através de atributos (\textit{Method Inheritance Factor} $$MIF = \frac{\sum_{i=1}^{rc} M_i(C_i)}{\sum_{i=1}^{rc} M_a(C_i)} $$
onde:
$$ M_a(C_i) = Md(C_i) + M_i(C_i)\textrm{, é o número total de métodos disponíveis}$$
De recordar que por métodos disponíveis entende-se os definidos localmente mais os herdados.

Por último temos o factor de herança de atributos (\textit{Attribute Inheritance Factor}) $$AIF = \frac{\sum_{i=1}^{rc} A_i(C_i)}{\sum_{i=1}^{rc} A_a(C_i)} $$
onde:
$$ A_a(C_i) = Ad(C_i) + A_i(C_i)\textrm{, é o número total de atributos disponíveis}$$
\paragraph{Métricas sobre Use Cases} (\textit{Use Case Metrics}) embora estejamos mais focados para as métricas sobre diagramas de classes,
também existem métricas que se aplicam a outros tipos de diagramas, como os Use Cases, assim é importante também explicar algumas elas
relativamente a uma anãlise quantitativa do sistema no que diz respeito à informação que conseguimos extraír de um diagrama deste tipo.
Assim conseguimos obter a complexidade do sistema através da informação obtida de um diagrama Use Case:
Contabilizar o número de actores, para ter uma noção sobre a quantidade de grupos de pessoas que
vão interagir com o sistema (\textit{Number of actors})  $$NOA = \sum_{i=1}^{n} noa_i $$
\\
O número de Use Cases que o sistema modela (\textit{Number of use cases})  $$NOUC = \sum_{i=1}^{n} nouc_i $$
\\
O nºumeor de Use Cases que cada actor tem diz-nos ou pode indicar a extensão com que cada utilizador pode
usufruir do sistema (\textit{Use cases per Actor}) $$UCPA = \sum_{i=1}^{n} nouca_i $$
