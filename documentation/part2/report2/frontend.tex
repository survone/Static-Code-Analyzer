\chapter{Front-end}
\minitoc
Como já tinhamos explicado na primeira milestone, decidimos que o nosso sistema vai tentar suportar ao máximo avaliação de métricas sobre código C.
Seria muito interessante suportar outras, mas acreditamos nesta altura que se o nosso sistema for extendido para suportar a avaliação de outras linguagens que não o C
então deveriamos recorrer a ferramentas externas que fizessem algum trabalho por nós.\\
Relativamente ao Front-end que utilizamos, ele está feito em Haskell e foi um GSoc (Google Summer of Code) feito em 2008, chama-se Language.C\footnote{Mais informação em: \url{http://trac.sivity.net/language\_c}}.
Este pacote de software apresenta um completo e bem testado parser e pretty printer para a definição da linguagem \textrm{C99} e ainda muitas das \textrm{GNU extensions}.\\

A nossa ideia é pegar em toda a investigação e trabalho dedicado à análise e descoberta de métricas, que estão descritas no Capítulo \ref{chap:metricas}, e implementa-las
utilizando este Front-end.\\

Inicialmente decidimos partir para a exploração da linguagem (dos tipos de dados) que estavam definidos neste parser. Rápidamente encontramos a AST da linguagem \textrm{C99}
e assim descobrimos que a linguagem C não é assim tão grande como estariamos à espera, como podemos ver no Apêndice \ref{chap:ast}.

\section{Estudo do Front-End}
Todos os tipos deste parser estão munidos de um \textrm{NodeInfo}, que nada mais é do que a informação relativa ao ficheiro, número de linha e coluna onde apareceu
esta derivação.\\
Um ficheiro em linguagem \textrm{C99} é representado como uma lista de declarações externas que pode ser uma declaração ou uma definição de função como podemos ver
na secção \ref{chap:extdefin}.

\begin{haskell}
data CTranslUnit = CTranslUnit [CExtDecl] NodeInfo
data CExtDecl = CDeclExt CDecl
              | CFDefExt CFunDef
              | CAsmExt CStrLit
\end{haskell}

Depois podemos ver que uma declaração externa pode ser então uma declaração como podemos ver na secção \ref{chap:decl}, vejamos o que é isto de declaração no \textrm{Haskell}:
\begin{haskell}
data CDecl = CDecl [CDeclSpec] [(Maybe CDeclr, Maybe CInit, Maybe CExpr)] NodeInfo
\end{haskell}
Este tipo de declarações é bastante abrangente e inclui declarações de estruturas de dados, declaração de parâmetros e tipos de dados.\\

Tal como  a definição é uma lista de declarações C e qualificadores:
\begin{haskell}
data CDeclSpec = CStorageSpec CStorageSpec  -- ^ storage-class specifier or typedef
               | CTypeSpec    CTypeSpec     -- ^ type name
               | CTypeQual    CTypeQual     -- ^ type qualifier

data CStorageSpec = CAuto     NodeInfo     -- ^ auto
                  | CRegister NodeInfo     -- ^ register
                  | CStatic   NodeInfo     -- ^ static
                  | CExtern   NodeInfo     -- ^ extern
                  | CTypedef  NodeInfo     -- ^ typedef
                  | CThread   NodeInfo     -- ^ GNUC thread local storage

data CTypeSpec = CVoidType    NodeInfo
               | CCharType    NodeInfo
               | CShortType   NodeInfo
               | CIntType     NodeInfo
               | CLongType    NodeInfo
               | CFloatType   NodeInfo
               | CDoubleType  NodeInfo
               | CSignedType  NodeInfo
               | CUnsigType   NodeInfo
               | CBoolType    NodeInfo
               | CComplexType NodeInfo
               | CSUType      CStructUnion NodeInfo  -- ^ Struct or Union specifier
               | CEnumType    CEnum        NodeInfo  -- ^ Enumeration specifier
               | CTypeDef     Ident        NodeInfo  -- ^ Typedef name
               | CTypeOfExpr  CExpr        NodeInfo  -- ^ @typeof(expr)@
               | CTypeOfType  CDecl        NodeInfo  -- ^ @typeof(type)@
\end{haskell}

E ainda uma lista de triplos de \textrm{Maybe}s.
