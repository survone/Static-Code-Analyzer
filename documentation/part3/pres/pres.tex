\documentclass{beamer}

\mode<presentation>
{
   \usetheme{EEng}
%   \usetheme{Warsaw}
  \setbeamercovered{transparent}
  \setbeamercolor{background canvas}{bg=black!0}
}

\usepackage{enumerate}
\usepackage{array}
\usepackage{graphics}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xcolor}
\usepackage{pgf}
\usepackage{hyperref}
\usepackage{url}
\usepackage{multicol}   % add-on
\usepackage{boxedminipage} 
\usepackage{indentfirst}   % add-on
\usepackage{float}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{boxedminipage}

% % % inicio do listings e ref
\definecolor{darkblue}{rgb}{0,0,0.6}
\definecolor{gray_ulisses}{gray}{0.55}
\definecolor{castanho_ulisses}{rgb}{0.71,0.33,0.14}
\definecolor{preto_ulisses}{rgb}{0.41,0.20,0.04}
\definecolor{green_ulises}{rgb}{0.2,0.75,0}

\hypersetup{
	a4paper,
	pdftex,
	bookmarks,
	colorlinks,
    citecolor=darkblue,
    linkcolor=darkblue,
    urlcolor=darkblue,
    filecolor=darkblue
}

\lstdefinelanguage{Terminall} {
       basicstyle=\scriptsize\ttfamily,
       breaklines=true,
       breakautoindent=false,
       showstringspaces=false
}
\lstnewenvironment{code_files}{\lstset{language=Terminall}}{}

\lstdefinelanguage{Terminal} {
       basicstyle=\tiny\ttfamily,
       breaklines=true,
       breakautoindent=false,
       showstringspaces=false
}
\lstnewenvironment{code}{\lstset{language=Terminal}}{}

\definecolor{gray_ulisses}{gray}{0.55}
\definecolor{castanho_ulisses}{rgb}{0.71,0.33,0.14}
\definecolor{preto_ulisses}{rgb}{0.41,0.20,0.04}
\definecolor{green_ulises}{rgb}{0.2,0.75,0}

\lstdefinelanguage{HaskellUlisses}
{
        basicstyle=\ttfamily\tiny,
        %backgroundcolor=\color{yellow},
        %frameshape={RYRYNYYYY}{yny}{yny}{RYRYNYYYY}, %contornos... muito nice...
        sensitive=true,
        morecomment=[l][\color{gray_ulisses}\ttfamily\tiny]{--},
        morecomment=[s][\color{gray_ulisses}\ttfamily\tiny]{\{-}{-\}},
        morestring=[b]",
        stringstyle=\color{red},
        showstringspaces=false,
%       numbers=left,
%       firstnumber=\thelstnumber,
        numberstyle=\tiny,
        numberblanklines=true,
        showspaces=false,
        breaklines=true,
        showtabs=false,
%       xleftmargin=15pt,
%       xrightmargin=-20pt,
        emph=
        {[1]
                FilePath,IOError,abs,acos,acosh,all,and,any,appendFile,approxRational,asTypeOf,asin,
                asinh,atan,atan2,atanh,basicIORun,break,catch,ceiling,chr,compare,concat,concatMap,
                const,cos,cosh,curry,cycle,decodeFloat,denominator,digitToInt,div,divMod,drop,
                dropWhile,either,elem,encodeFloat,enumFrom,enumFromThen,enumFromThenTo,enumFromTo,
                error,even,exp,exponent,fail,filter,flip,floatDigits,floatRadix,floatRange,floor,
                fmap,foldl,foldl1,foldr,foldr1,fromDouble,fromEnum,fromInt,fromInteger,fromIntegral,
                fromRational,fst,gcd,getChar,getContents,getLine,head,id,inRange,index,init,intToDigit,
                interact,ioError,isAlpha,isAlphaNum,isAscii,isControl,isDenormalized,isDigit,isHexDigit,
                isIEEE,isInfinite,isLower,isNaN,isNegativeZero,isOctDigit,isPrint,isSpace,isUpper,iterate,
                last,lcm,length,lex,lexDigits,lexLitChar,lines,log,logBase,lookup,map,mapM,mapM_,max,
                maxBound,maximum,maybe,min,minBound,minimum,mod,negate,not,notElem,null,numerator,odd,
                or,ord,otherwise,pi,pred,primExitWith,print,product,properFraction,putChar,putStr,putStrLn,quot,
                quotRem,range,rangeSize,read,readDec,readFile,readFloat,readHex,readIO,readInt,readList,readLitChar,
                readLn,readOct,readParen,readSigned,reads,readsPrec,realToFrac,recip,rem,repeat,replicate,return,
                reverse,round,scaleFloat,scanl,scanl1,scanr,scanr1,seq,sequence,sequence_,show,showChar,showInt,
                showList,showLitChar,showParen,showSigned,showString,shows,showsPrec,significand,signum,sin,
                sinh,snd,span,splitAt,sqrt,subtract,succ,sum,tail,take,takeWhile,tan,tanh,threadToIOResult,toEnum,
                toInt,toInteger,toLower,toRational,toUpper,truncate,uncurry,undefined,unlines,until,unwords,unzip,
                unzip3,userError,words,writeFile,zip,zip3,zipWith,zipWith3,listArray,doParse
        },
        emphstyle={[1]\color{blue}},
        emph=
        {[2]
                Bool,Char,Double,Either,Float,IO,Integer,Int,Maybe,Ordering,Rational,Ratio,ReadS,ShowS,String,
                Word8,InPacket
        },
        emphstyle={[2]\color{castanho_ulisses}},
        emph=
        {[3]
                case,class,data,deriving,do,else,if,import,in,infixl,infixr,instance,let,
                module,of,primitive,then,type,where
        },
        emphstyle={[3]\color{preto_ulisses}\textbf},
        emph=
        {[4]
                quot,rem,div,mod,elem,notElem,seq
        },
        emphstyle={[4]\color{castanho_ulisses}\textbf},
        emph=
        {[5]
                EQ,False,GT,Just,LT,Left,Nothing,Right,True,Show,Eq,Ord,Num
        },
        emphstyle={[5]\color{preto_ulisses}\textbf}
}
\lstnewenvironment{haskell}{\lstset{language=HaskellUlisses}}{}
% % % fim do listings e ref

% % % inicio da definicao de comandos

% % % fim da definicao de comandos

\title{SOPAS - Submissão Online Para Análise de Software (fase 3)}
\author{José Pedro Silva \and
Pedro Faria \and
Ulisses Costa
}

\date{\today}
\institute{Engenharia de Linguagens\\
Projecto integrado
}

\AtBeginSubsection[] {
  \begin{frame}<beamer>
    \frametitle{Index}
    \scriptsize{\tableofcontents[currentsection,currentsubsection]}
  \end{frame}
}

\AtBeginSection[] {
  \begin{frame}<beamer>
    \frametitle{Index}
    \scriptsize{\tableofcontents[currentsection]}
  \end{frame}
}
\begin{document}
\begin{frame}
   \titlepage
\end{frame}

\section{Objectivos}
\begin{frame} \frametitle{Até agora:}
Concretizado até ao ínicio da terceira fase:
\begin{itemize}
\item Estudo do language.C {\color{green}$\checkmark$}
\item Estudo das métricas {\color{green}$\checkmark$}
\item Maturação da WebApp {\color{green}$\checkmark$}
\item Inicio da implementação do acesso pelo Terminal {\color{green}$\checkmark$}
\end{itemize}
\end{frame}
\pgfdeclareimage[width=.8\textwidth]{topo}{images/topo}

\begin{frame} \frametitle{Motivação e Objectivos}
Objectivos para terceira fase:
\begin{itemize}
\item Terminar a aplicação web esteticamente
\item Início da implementação de uma \emph{script} de instalação do sistema
\item Implementação de algumas métricas
\item Melhoramento no interface pelo Terminal
\end{itemize}
\end{frame}

\section{Aplicação Web}
\begin{frame}[fragile] \frametitle{Estado da aplicação Web}
A aplicação está praticamente terminada, o que se pretende fazer daqui para a frente será melhorar o que está feito e adicionar alguns extras. O que estava implementado até à entrega da fase anterior:
\begin{itemize}
\item Criação de contas de utilizador (grupo)
\item Associação de concorrentes a determinado grupo
\item Criação de concursos
\item Criação de enunciados (através da interface web ou submetendo em formato xml)
\end{itemize}
\end{frame}

\begin{frame}[fragile] \frametitle{Estado da aplicação Web (parte 2)}
\begin{itemize}
\item Inserção de baterias de teste para os enunciados
\item Submissão de programas para avaliação
\item Adição simplificada de novas funções de avaliação ou de novas linguagens de programação ao sistema
\item Apresentação de resultados referentes às diversas tentativas
\end{itemize}
\end{frame}

\begin{frame}[fragile] \frametitle{Novidades}
\begin{itemize}
\item Limaram-se alguns aspectos na interface, a nível de acessibilidade
\item Alterou-se o script de detecção de clones, escrito em perl, de forma a interagir melhor com a aplicação
\item Adicionou-se à aplicação a funcionalidade de detecção de clones
\end{itemize}
\end{frame}

\begin{frame}[fragile] \frametitle{Modo de utilização do script de detecção de clones (CloneDt.pl)}
\begin{block}{Modo de utilização}
perl cloneDt.pl -file [path1] -comp [path2]
\end{block}
\begin{itemize}
\item em que [path1] representa o path do ficheiro que se acabou de submeter, e o path2 representa o path do ficheiro com o qual se pretende comparar o primeiro 
\end{itemize}
\end{frame}


\begin{frame}[fragile] \frametitle{Detalhes do script de detecção de clones (CloneDt.pl)}
\begin{itemize}
\item utiliza o comando 
\begin{block}{Comando ctags}
ctags -x [path]
\end{block}
de forma a obter as linhas referentes ao início de cada função
\item lê o ficheiro e guarda o código de cada função, numa posição de array diferente
\item remove espaços em branco e comentários
\item substituí strings por 'S', números por '1' e variáveis por 'var' 
\end{itemize}
\end{frame}


\begin{frame}[fragile] \frametitle{Detalhes do script de detecção de clones (CloneDt.pl)}
\begin{itemize}
\item repete o mesmo processo para o segundo ficheiro
\item compara cada elemento do primeiro array gerado com os elementos do segundo array
\item regista cada vez que encontra uma função que pode ser cópia de outra
\item no fim imprime para o stdout a percentagem de funções que foram assinaladas como clones
\end{itemize}
\end{frame}

\begin{frame}[fragile] \frametitle{Detecção de clones na aplicação}
\begin{itemize}
\item cada vez que um utilizador submete uma proposta de resolução, o seu código é comparado com o código das tentativas mais recentes dos restantes grupos, para o mesmo enunciado
\item quando encontra possíveis clones, adiciona uma entrada na base de dados
\end{itemize}
\end{frame}


\section{Terminal Interface}
\begin{frame}[fragile] \frametitle{Melhoramentos}
\begin{itemize}
 \item Implementação com sucesso de um sistema por comandos.
 \item Criação de um módulo, \texttt{Access.pm}, de comunicação entre a camada de dados.
\begin{itemize}
 \item Usando módulo \texttt{Moose}
\end{itemize}
 \item Aumento da área de cobertura entre a interface e o sistema.
\end{itemize}
\end{frame}

\section{Instalação do sistema}
\begin{frame}[fragile] \frametitle{Instalação do sistema}
\begin{itemize}
 \item Implementar uma \emph{script} de instalação de todo o \emph{software} envolvido no sistema
 \item \emph{Script} em \emph{bash}
\end{itemize}
\end{frame}

\begin{frame}[fragile] \frametitle{Vantagens}
\begin{itemize}
 \item Facilitar a manutenção sistema
 \item Facilidade em migrar o sistema
 \item Gerir versões de \emph{software} usados pelo sistema
 \item Novas \emph{skills} de administração de sistemas
\end{itemize}
\end{frame}

\subsection{Software Instalado}
\begin{frame}[fragile] \frametitle{Software instalado}
De momento, a \emph{script} instala:

\begin{itemize}
 \item \texttt{Perl} e módulos
 \item Bibliotecas \texttt{C} 
 \item \texttt{Haskell} e derivados
 \item \texttt{Ruby}, \texttt{Rails} e \texttt{Gems}
\end{itemize}
\end{frame}

\subsection{Início e Exemplo}
\begin{frame}[fragile] \frametitle{Início I - Verificação do utilizador}
A primeira função invocada:
\begin{block}{Check\_user\_id}
\begin{haskell}
andlogfile="tee -a main.log"

function check_user_id {
        echo "`whoami` started this script installation file at `date`" | $andlogfile
        if [ ! "`whoami`" = "root" ]; then
                echo "Not running as root. Yes, this is an installation file..." | $andlogfile
                exit 1 ;
        fi
}
\end{haskell}
\end{block}
\end{frame}

\begin{frame}[fragile] \frametitle{Início II - Verificação do sistema}
\begin{block}{install\_package}
\begin{haskell}
function install_package {
        case `uname -s` in
                "Darwin")       install_macosx
                                ;;
                "Linux")        case `uname -v` in
                                *"Ubuntu"*)   install_ubuntu
                                              ;;
                                *)            echo "Your Linux is not supported yet. If it does have a packet manager please send an email to $admin_email"
                                              exit 1;
                                              ;;
                                esac
                        ;;
                *)		echo "Your operative system is not supported yet. Please send an email to $admin_email"
                        exit 1;
                        ;;
        esac
}
\end{haskell}
\end{block}
\end{frame}

\begin{frame}[fragile] \frametitle{Exemplo I - Invocação da função geral}
\begin{block}{install\_macosx}
\begin{haskell}
function install_macosx {
        echo "Working on a MacOSX machine" | $andlogfile
        build_macosx
        $portins gd2
        install_perl_mac
        install_perl_modules
}
\end{haskell}
\end{block}
\end{frame}

\begin{frame}[fragile] \frametitle{Exemplo II - \texttt{Haskell} e derivados}
Função \texttt{build\_macosx} trata de instalar:
\begin{itemize}
 \item \texttt{GHCi} - Compilador de \texttt{Haskell}, juntamente com o interpretador.
 \item \texttt{Happy} - Gerador de \emph{parsers} desenvolvido em \texttt{Haskell}
 \item \texttt{Alex} - Gerador de analisadores léxicos desenvolvido em \texttt{Haskell}
 \item \texttt{Language.C} - Biblioteca do \texttt{Haskell} para análise e geração de código \texttt{C}
\end{itemize}
\end{frame}

\begin{frame}[fragile] \frametitle{Exemplo III - Instalação}
\begin{block}{build\_macosx}
\begin{haskell}
function build_macosx {
        is_ghc_installed
        if [ $? -eq 1 ]; then
                echo "GHC is installed, I will continue..."
                is_ghc_package_installed "happy"
                if [ $? -eq 0 ]; then
                        echo "Happy is not installed, I will install"
                        $portins hs-happy
                fi
                is_ghc_package_installed "alex"
                if [ $? -eq 0 ]; then
                        echo "Alex is not installed, I will install"
                        $portins hs-alex
                fi
                is_ghc_package_installed "language"
                if [ $? -eq 0 ]; then
                        echo "Language.C is not installed, I will install"
                        build_language_c
                        cd Parser/language-c-0.3.2.1/
                        runhaskell Setup.hs install
                        cd -
                fi
\end{haskell}
\end{block}
\end{frame}


\section{Strafunski}
\begin{frame}[fragile] \frametitle{Strafunski}
\begin{itemize}
\item SYB (Scrap Your Boilerplate\footnote{\url{http://www.cs.uu.nl/wiki/GenericProgramming/SYB}}) - Programação genérica
\item Implementa estratégias no paradigma funcional
\end{itemize}

\begin{block}{Data.Data (SYB)}
$$gfoldl :: (c~(d \rightarrow b) \rightarrow d \rightarrow c~b) \rightarrow (g \rightarrow c~g) \rightarrow a \rightarrow c~a$$
$$gunfold :: (c (b \rightarrow r) \rightarrow c~r) \rightarrow (r \rightarrow c~r) \rightarrow Constr \rightarrow c~a$$
$$gmapT :: (b \rightarrow b) \rightarrow a \rightarrow a$$
\end{block}
\end{frame}

\begin{frame}[fragile] \frametitle{Porquê Strafunski? - Language.C exemplo}
\begin{block}{void fun(int a, int b);}
\begin{haskell}
CTranslUnit 
[CDeclExt
(CDecl
[CTypeSpec (CVoidType(NodeInfo("main.c", 2, 1) (Name { nameId = 1 })))]
[ (Just
(CDeclr (Just "fun")
[CFunDeclr (Right
([CDecl [CTypeSpec (CIntType (NodeInfo ("main.c",2,11) (Name {nameId = 4})))]
[(Just (CDeclr (Just "a")[] Nothing[] (NodeInfo("main.c", 2, 15)
(Name { nameId = 5 })))
,Nothing, Nothing)] (NodeInfo("main.c", 2, 11) (Name { nameId = 6 }))
,CDecl [CTypeSpec(CIntType(NodeInfo("main.c", 2, 18) (Name { nameId = 8 })))]
[(Just(CDeclr(Just "b") [] Nothing [] (NodeInfo ("main.c",2,22)
(Name {nameId = 9})))
,Nothing,Nothing)]
(NodeInfo ("main.c",2,18) (Name {nameId = 10}))],False))
[] (NodeInfo ("main.c",2,10) (Name {nameId = 11}))
]
Nothing [] (NodeInfo ("main.c",2,6) (Name {nameId = 2}))
)
,Nothing
,Nothing
)
] (NodeInfo ("main.c",2,1) (Name {nameId = 12})))]
\end{haskell}
\end{block}
\end{frame}

\begin{frame} \frametitle{Porquê Strafunski? - Como tratar arvores grandes (sem SYB)}
\begin{alertblock}{\textbf{Muito} trabalhoso}
\begin{itemize}
\item Ter uma função para cada tipo de dados (no caso do Language.C 28)
\item Ter uma acção para cada constructor de tipos (no caso do Language.C 84)
\end{itemize}
\end{alertblock}
Rápidamente se atinge perto de 200 linhas de código para fazer uma travessia na árvore e executar uma acção num constructor\footnote{\url{https://github.com/ulisses/Static-Code-Analyzer/blob/95032a7e3eaf52e0dc6c36d3c1039519bc5fe689/Parser/Main.hs}}.
\end{frame}

\begin{frame} \frametitle{Porquê Strafunski? - Como tratar arvores grandes (com SYB)}
\begin{exampleblock}{\textbf{Pouco} trabalhoso, genérico}
\begin{itemize}
\item Definir a acção que se quer tomar sobre o nodo em causa
\item Definir uma estratégia
\end{itemize}
\end{exampleblock}
Com pouco código definimos uma estratégia e uma acção sobre a árvore de parsing
\end{frame}

\begin{frame} \frametitle{Strafunski - Estratégias}
Para a aplicação de uma estratégia a uma instância do nosso tipo de dados $t$ iremos usar:
$$applyTP :: (Monad~m, Term~t) \Rightarrow TP~m \rightarrow t \rightarrow m~t$$
$$applyTU :: (Monad~m, Term~t) \Rightarrow TU~u~m \rightarrow t \rightarrow m~u$$

Permite adicionar estratégias:
$$adhocTP :: (Monad~m, Term~t) \Rightarrow TP~m \rightarrow (t \rightarrow m t) \rightarrow TP~m$$
$$adhocTU :: (Monad~m, Term~t) \Rightarrow TU a m \rightarrow (t \rightarrow m u) \rightarrow TU~u~m$$
\end{frame}

\begin{frame} \frametitle{Strafunski - Estratégias 2}
Permite executar estratégias em sequência:
$$seqTP :: Monad~m \Rightarrow TP~m \rightarrow TP~m \rightarrow TP~m$$
$$seqTU :: Monad~m \Rightarrow TP~m \rightarrow TU~u~m \rightarrow TU~u~m$$

Para tentar usar estratégias diferentes:
$$choiceTP :: MonadPlus~m \Rightarrow TP~m \rightarrow TP~m \rightarrow TP~m$$
$$choiceTU :: MonadPlus~m \Rightarrow TU~u~m \rightarrow TU~u~m \rightarrow TU~u~m$$
\end{frame}

\begin{frame} \frametitle{Strafunski - Estratégias 3}
Aplica esta estratégia a todos os subtermos imediatos, para o \textbf{TU} os resultados são reduzidos com a função do monoid $+$:
$$allTP :: Monad~m \Rightarrow TP~m \rightarrow TP~m$$
$$allTU :: (Monad~m, Monoid~u) \Rightarrow TU~u~m \rightarrow TU~u~m$$

Esta função permite aplicar a estratégia ao primeiro filho que aparecer da esquerda para a direita:
$$once\_tdTP,once\_buTP :: MonadPlus~m \Rightarrow TP~m \rightarrow TP~m$$
$$once\_tdTU, once\_buTU :: MonadPlus~m \Rightarrow TU~u~m \rightarrow TU~u~m$$
\end{frame}

\begin{frame}[fragile] \frametitle{TU vs TP}
\begin{haskell}
full_tdTU   :: (Monad m, Monoid a) => TU a m -> TU a m
full_tdTU s =  op2TU mappend s (allTU' (full_tdTU s))
\end{haskell}

\begin{haskell}
class Monoid a where
  mempty :: a
  mappend :: a -> a -> a
  mconcat :: [a] -> a
    -- Defined in Data.Monoid
\end{haskell}

\begin{haskell}
full_tdTP   :: Monad m => TP m -> TP m
full_tdTP s =  s `seqTP` (allTP (full_tdTP s))
\end{haskell}
\end{frame}

\begin{frame}[fragile] \frametitle{Strafunski - Exemplos}
Contar o número de $ifs$, $switches$ e ciclos (McCabeIndex$--$).
\begin{haskell}
testMcCabe :: IO Int 
testMcCabe =  parse >>= mcCabeIndex . fromRight
    where fromRight = (\(Right prog) -> prog)
          parse = parseCFile (newGCC "gcc") Nothing ["-U__BLOCKS__"] "main.c"

instance Num a => Monoid a where
    mappend = (+) 
    mempty = 0 
        
mcCabeIndex :: Data a => a -> IO Int 
mcCabeIndex =  applyTU (full_tdTU loopCond)
        
loopCond = constTU 0 `adhocTU` (return . action)

action :: Num a => CStat -> a
action (CIf _ _ _ _)    = 1
action (CSwitch _ _ _)  = 1
action (CWhile _ _ _ _) = 1
action (CFor _ _ _ _ _) = 1
action _                = 0
\end{haskell}
\end{frame}

\begin{frame}[fragile] \frametitle{Strafunski - Exemplos}
Extrair as assinaturas de todas as funções.
\begin{haskell}
getFunctionsSign :: IO [CTranslUnit]
getFunctionsSign = parse >>= return . getFunSign . fromRight
    where fromRight = (\(Right prog) -> prog)
          parse = parseCFile (newGCC "gcc") Nothing ["-U__BLOCKS__"] "main.c"

getFunSign :: Data x => x -> [x]
getFunSign = applyTP (topdown names1)
    where names1 = idTP `adhocTP` (return . fromFunctionToSign)

fromFunctionToSign (CFDefExt (CFunDef lCDeclSpec cDeclr _ _ _ ))
    = CDeclExt (CDecl lCDeclSpec [(Just $ cDeclr,Nothing,Nothing)] internalNode)
\end{haskell}
\end{frame}

\section{Conclusão e trabalho futuro}
\begin{frame} \frametitle{Conclusão e trabalho futuro}
\end{frame}

\section*{Perguntas}
\begin{frame} \frametitle{Perguntas}
\begin{center}\huge{?}\end{center}
\end{frame}

\end{document}
