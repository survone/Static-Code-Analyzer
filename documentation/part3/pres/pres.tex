\documentclass{beamer}

\mode<presentation>
{
   \usetheme{EEng}
%   \usetheme{Warsaw}
  \setbeamercovered{transparent}
  \setbeamercolor{background canvas}{bg=black!0}
}

\usepackage{enumerate}
\usepackage{array}
\usepackage{graphics}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xcolor}
\usepackage{pgf}
\usepackage{hyperref}
\usepackage{url}
\usepackage{multicol}   % add-on
\usepackage{boxedminipage} 
\usepackage{indentfirst}   % add-on
\usepackage{float}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{boxedminipage}

% % % inicio do listings e ref
\definecolor{darkblue}{rgb}{0,0,0.6}
\definecolor{gray_ulisses}{gray}{0.55}
\definecolor{castanho_ulisses}{rgb}{0.71,0.33,0.14}
\definecolor{preto_ulisses}{rgb}{0.41,0.20,0.04}
\definecolor{green_ulises}{rgb}{0.2,0.75,0}

\hypersetup{
	a4paper,
	pdftex,
	bookmarks,
	colorlinks,
    citecolor=darkblue,
    linkcolor=darkblue,
    urlcolor=darkblue,
    filecolor=darkblue
}

\lstdefinelanguage{Terminall} {
       basicstyle=\scriptsize\ttfamily,
       breaklines=true,
       breakautoindent=false,
       showstringspaces=false
}
\lstnewenvironment{code_files}{\lstset{language=Terminall}}{}

\lstdefinelanguage{Terminal} {
       basicstyle=\tiny\ttfamily,
       breaklines=true,
       breakautoindent=false,
       showstringspaces=false
}
\lstnewenvironment{code}{\lstset{language=Terminal}}{}

\definecolor{gray_ulisses}{gray}{0.55}
\definecolor{castanho_ulisses}{rgb}{0.71,0.33,0.14}
\definecolor{preto_ulisses}{rgb}{0.41,0.20,0.04}
\definecolor{green_ulises}{rgb}{0.2,0.75,0}

\lstdefinelanguage{HaskellUlisses}
{
        basicstyle=\ttfamily\tiny,
        %backgroundcolor=\color{yellow},
        %frameshape={RYRYNYYYY}{yny}{yny}{RYRYNYYYY}, %contornos... muito nice...
        sensitive=true,
        morecomment=[l][\color{gray_ulisses}\ttfamily\tiny]{--},
        morecomment=[s][\color{gray_ulisses}\ttfamily\tiny]{\{-}{-\}},
        morestring=[b]",
        stringstyle=\color{red},
        showstringspaces=false,
%       numbers=left,
%       firstnumber=\thelstnumber,
        numberstyle=\tiny,
        numberblanklines=true,
        showspaces=false,
        breaklines=true,
        showtabs=false,
%       xleftmargin=15pt,
%       xrightmargin=-20pt,
        emph=
        {[1]
                FilePath,IOError,abs,acos,acosh,all,and,any,appendFile,approxRational,asTypeOf,asin,
                asinh,atan,atan2,atanh,basicIORun,break,catch,ceiling,chr,compare,concat,concatMap,
                const,cos,cosh,curry,cycle,decodeFloat,denominator,digitToInt,div,divMod,drop,
                dropWhile,either,elem,encodeFloat,enumFrom,enumFromThen,enumFromThenTo,enumFromTo,
                error,even,exp,exponent,fail,filter,flip,floatDigits,floatRadix,floatRange,floor,
                fmap,foldl,foldl1,foldr,foldr1,fromDouble,fromEnum,fromInt,fromInteger,fromIntegral,
                fromRational,fst,gcd,getChar,getContents,getLine,head,id,inRange,index,init,intToDigit,
                interact,ioError,isAlpha,isAlphaNum,isAscii,isControl,isDenormalized,isDigit,isHexDigit,
                isIEEE,isInfinite,isLower,isNaN,isNegativeZero,isOctDigit,isPrint,isSpace,isUpper,iterate,
                last,lcm,length,lex,lexDigits,lexLitChar,lines,log,logBase,lookup,map,mapM,mapM_,max,
                maxBound,maximum,maybe,min,minBound,minimum,mod,negate,not,notElem,null,numerator,odd,
                or,ord,otherwise,pi,pred,primExitWith,print,product,properFraction,putChar,putStr,putStrLn,quot,
                quotRem,range,rangeSize,read,readDec,readFile,readFloat,readHex,readIO,readInt,readList,readLitChar,
                readLn,readOct,readParen,readSigned,reads,readsPrec,realToFrac,recip,rem,repeat,replicate,return,
                reverse,round,scaleFloat,scanl,scanl1,scanr,scanr1,seq,sequence,sequence_,show,showChar,showInt,
                showList,showLitChar,showParen,showSigned,showString,shows,showsPrec,significand,signum,sin,
                sinh,snd,span,splitAt,sqrt,subtract,succ,sum,tail,take,takeWhile,tan,tanh,threadToIOResult,toEnum,
                toInt,toInteger,toLower,toRational,toUpper,truncate,uncurry,undefined,unlines,until,unwords,unzip,
                unzip3,userError,words,writeFile,zip,zip3,zipWith,zipWith3,listArray,doParse
        },
        emphstyle={[1]\color{blue}},
        emph=
        {[2]
                Bool,Char,Double,Either,Float,IO,Integer,Int,Maybe,Ordering,Rational,Ratio,ReadS,ShowS,String,
                Word8,InPacket
        },
        emphstyle={[2]\color{castanho_ulisses}},
        emph=
        {[3]
                case,class,data,deriving,do,else,if,import,in,infixl,infixr,instance,let,
                module,of,primitive,then,type,where
        },
        emphstyle={[3]\color{preto_ulisses}\textbf},
        emph=
        {[4]
                quot,rem,div,mod,elem,notElem,seq
        },
        emphstyle={[4]\color{castanho_ulisses}\textbf},
        emph=
        {[5]
                EQ,False,GT,Just,LT,Left,Nothing,Right,True,Show,Eq,Ord,Num
        },
        emphstyle={[5]\color{preto_ulisses}\textbf}
}
\lstnewenvironment{haskell}{\lstset{language=HaskellUlisses}}{}
% % % fim do listings e ref

% % % inicio da definicao de comandos

% % % fim da definicao de comandos

\title{SOPAS - Submissão Online Para Análise de Software (fase 3)}
\author{José Pedro Silva \and
Pedro Faria \and
Ulisses Costa
}

\date{\today}
\institute{Engenharia de Linguagens\\
Projecto integrado
}

\AtBeginSubsection[] {
  \begin{frame}<beamer>
    \frametitle{Index}
    \scriptsize{\tableofcontents[currentsection,currentsubsection]}
  \end{frame}
}

\AtBeginSection[] {
  \begin{frame}<beamer>
    \frametitle{Index}
    \scriptsize{\tableofcontents[currentsection]}
  \end{frame}
}
\begin{document}
\begin{frame}
   \titlepage
\end{frame}

\section{Objectivos}
\begin{frame} \frametitle{Até agora:}
Concretizado até ao ínicio da terceira fase:
\begin{itemize}
\item Estudo do language.C {\color{green}$\checkmark$}
\item Estudo das métricas {\color{green}$\checkmark$}
\item Maturação da WebApp {\color{green}$\checkmark$}
\item Inicio da implementação do acesso pelo Terminal {\color{green}$\checkmark$}
\end{itemize}
\end{frame}
\pgfdeclareimage[width=.8\textwidth]{topo}{images/topo}

\begin{frame} \frametitle{Motivação e Objectivos}
Objectivos para terceira fase:
\begin{itemize}
\item Terminar a aplicação web esteticamente
\item Implementação de algumas métricas
\item Melhoramento no interface pelo Terminal
\end{itemize}
\end{frame}

\section{Aplicação Web}

\section{Terminal Interface}

\section{Strafunski}
\begin{frame}[fragile] \frametitle{Strafunski}
\begin{itemize}
\item SYB (Scrap Your Boilerplate\footnote{\url{http://www.cs.uu.nl/wiki/GenericProgramming/SYB}}) - Programação genérica
\item Implementa estratégias no paradigma funcional
\end{itemize}

\begin{block}{Data.Data (SYB)}
$$gfoldl :: (c~(d \rightarrow b) \rightarrow d \rightarrow c~b) \rightarrow (g \rightarrow c~g) \rightarrow a \rightarrow c~a$$
$$gunfold :: (c (b \rightarrow r) \rightarrow c~r) \rightarrow (r \rightarrow c~r) \rightarrow Constr \rightarrow c~a$$
$$gmapT :: (b \rightarrow b) \rightarrow a \rightarrow a$$
\end{block}
\end{frame}

\begin{frame}[fragile] \frametitle{Porquê Strafunski? - Language.C exemplo}
\begin{block}{void fun(int a, int b);}
\begin{haskell}
CTranslUnit 
[CDeclExt
(CDecl
[CTypeSpec (CVoidType(NodeInfo("main.c", 2, 1) (Name { nameId = 1 })))]
[ (Just
(CDeclr (Just "fun")
[CFunDeclr (Right
([CDecl [CTypeSpec (CIntType (NodeInfo ("main.c",2,11) (Name {nameId = 4})))]
[(Just (CDeclr (Just "a")[] Nothing[] (NodeInfo("main.c", 2, 15)
(Name { nameId = 5 })))
,Nothing, Nothing)] (NodeInfo("main.c", 2, 11) (Name { nameId = 6 }))
,CDecl [CTypeSpec(CIntType(NodeInfo("main.c", 2, 18) (Name { nameId = 8 })))]
[(Just(CDeclr(Just "b") [] Nothing [] (NodeInfo ("main.c",2,22)
(Name {nameId = 9})))
,Nothing,Nothing)]
(NodeInfo ("main.c",2,18) (Name {nameId = 10}))],False))
[] (NodeInfo ("main.c",2,10) (Name {nameId = 11}))
]
Nothing [] (NodeInfo ("main.c",2,6) (Name {nameId = 2}))
)
,Nothing
,Nothing
)
] (NodeInfo ("main.c",2,1) (Name {nameId = 12})))]
\end{haskell}
\end{block}
\end{frame}

\begin{frame} \frametitle{Porquê Strafunski? - Como tratar arvores grandes (sem SYB)}
\begin{alertblock}{\textbf{Muito} trabalhoso}
\begin{itemize}
\item Ter uma função para cada tipo de dados (no caso do Language.C 28)
\item Ter uma acção para cada constructor de tipos (no caso do Language.C 84)
\end{itemize}
\end{alertblock}
Rápidamente se atinge perto de 200 linhas de código para fazer uma travessia na árvore e executar uma acção num constructor\footnote{\url{https://github.com/ulisses/Static-Code-Analyzer/blob/95032a7e3eaf52e0dc6c36d3c1039519bc5fe689/Parser/Main.hs}}.
\end{frame}

\begin{frame} \frametitle{Porquê Strafunski? - Como tratar arvores grandes (com SYB)}
\begin{exampleblock}{\textbf{Pouco} trabalhoso, genérico}
\begin{itemize}
\item Definir a acção que se quer tomar sobre o nodo em causa
\item Definir uma estratégia
\end{itemize}
\end{exampleblock}
Com pouco código definimos uma estratégia e uma acção sobre a árvore de parsing
\end{frame}

\begin{frame} \frametitle{Strafunski - Estratégias}
Para a aplicação de uma estratégia a uma instância do nosso tipo de dados $t$ iremos usar:
$$applyTP :: (Monad~m, Term~t) \Rightarrow TP~m \rightarrow t \rightarrow m~t$$
$$applyTU :: (Monad~m, Term~t) \Rightarrow TU~u~m \rightarrow t \rightarrow m~u$$

Permite adicionar estratégias:
$$adhocTP :: (Monad~m, Term~t) \Rightarrow TP~m \rightarrow (t \rightarrow m t) \rightarrow TP~m$$
$$adhocTU :: (Monad~m, Term~t) \Rightarrow TU a m \rightarrow (t \rightarrow m u) \rightarrow TU~u~m$$
\end{frame}

\begin{frame} \frametitle{Strafunski - Estratégias 2}
Permite executar estratégias em sequência:
$$seqTP :: Monad~m \Rightarrow TP~m \rightarrow TP~m \rightarrow TP~m$$
$$seqTU :: Monad~m \Rightarrow TP~m \rightarrow TU~u~m \rightarrow TU~u~m$$

Para tentar usar estratégias diferentes:
$$choiceTP :: MonadPlus~m \Rightarrow TP~m \rightarrow TP~m \rightarrow TP~m$$
$$choiceTU :: MonadPlus~m \Rightarrow TU~u~m \rightarrow TU~u~m \rightarrow TU~u~m$$
\end{frame}

\begin{frame} \frametitle{Strafunski - Estratégias 3}
Aplica esta estratégia a todos os subtermos imediatos, para o \textbf{TU} os resultados são reduzidos com a função do monoid $+$:
$$allTP :: Monad~m \Rightarrow TP~m \rightarrow TP~m$$
$$allTU :: (Monad~m, Monoid~u) \Rightarrow TU~u~m \rightarrow TU~u~m$$

Esta função permite aplicar a estratégia ao primeiro filho que aparecer da esquerda para a direita:
$$once\_tdTP,once\_buTP :: MonadPlus~m \Rightarrow TP~m \rightarrow TP~m$$
$$once\_tdTU, once\_buTU :: MonadPlus~m \Rightarrow TU~u~m \rightarrow TU~u~m$$
\end{frame}

\begin{frame}[fragile] \frametitle{TU vs TP}
\begin{haskell}
full_tdTU   :: (Monad m, Monoid a) => TU a m -> TU a m
full_tdTU s =  op2TU mappend s (allTU' (full_tdTU s))
\end{haskell}

\begin{haskell}
class Monoid a where
  mempty :: a
  mappend :: a -> a -> a
  mconcat :: [a] -> a
    -- Defined in Data.Monoid
\end{haskell}

\begin{haskell}
full_tdTP   :: Monad m => TP m -> TP m
full_tdTP s =  s `seqTP` (allTP (full_tdTP s))
\end{haskell}
\end{frame}

\begin{frame}[fragile] \frametitle{Strafunski - Exemplos}
Contar o número de $ifs$, $switches$ e ciclos (McCabeIndex$--$).
\begin{haskell}
testMcCabe :: IO Int 
testMcCabe =  parse >>= mcCabeIndex . fromRight
    where fromRight = (\(Right prog) -> prog)
          parse = parseCFile (newGCC "gcc") Nothing ["-U__BLOCKS__"] "main.c"

instance Num a => Monoid a where
    mappend = (+) 
    mempty = 0 
        
mcCabeIndex :: Data a => a -> IO Int 
mcCabeIndex =  applyTU (full_tdTU loopCond)
        
loopCond = constTU 0 `adhocTU` (return . action)

action :: Num a => CStat -> a
action (CIf _ _ _ _)    = 1
action (CSwitch _ _ _)  = 1
action (CWhile _ _ _ _) = 1
action (CFor _ _ _ _ _) = 1
action _                = 0
\end{haskell}
\end{frame}

\begin{frame}[fragile] \frametitle{Strafunski - Exemplos}
Extrair as assinaturas de todas as funções.
\begin{haskell}
getFunctionsSign :: IO [CTranslUnit]
getFunctionsSign = parse >>= return . getFunSign . fromRight
    where fromRight = (\(Right prog) -> prog)
          parse = parseCFile (newGCC "gcc") Nothing ["-U__BLOCKS__"] "main.c"

getFunSign :: Data x => x -> [x]
getFunSign = applyTP (topdown names1)
    where names1 = idTP `adhocTP` (return . fromFunctionToSign)

fromFunctionToSign (CFDefExt (CFunDef lCDeclSpec cDeclr _ _ _ ))
    = CDeclExt (CDecl lCDeclSpec [(Just $ cDeclr,Nothing,Nothing)] internalNode)
\end{haskell}
\end{frame}

\section{Conclusão e trabalho futuro}
\begin{frame} \frametitle{Conclusão e trabalho futuro}
\end{frame}

\section*{Perguntas}
\begin{frame} \frametitle{Perguntas}
\begin{center}\huge{?}\end{center}
\end{frame}

\end{document}
